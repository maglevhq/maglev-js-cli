import {Command, Flags} from '@oclif/core'
import {SectionDefinition} from '../maglev/types'
import glob = require('glob')
import path = require('path')
import fs = require('fs')
import Ajv from 'ajv'
import SectionJsonSchema from '../maglev/section.schema.json'
import {camelize} from '../utils'

export default class Codegen extends Command {
  static description = 'Generate the Typescript types from the Section definitions'

  static examples = [
    '<%= config.bin %> <%= command.id %>',
  ]

  static flags = {
    // flag with a value (-p, --path=VALUE)
    path: Flags.string({char: 'p', description: 'path to the Javascript application (Nuxt, ...etc)'}),
  }

  public async run(): Promise<void> {
    const {flags} = await this.parse(Codegen)
    this.log("ðŸ‘‹ Hi! We're going to generate the types for your sections:\n")
    await this.codegen(flags.path || process.cwd())
    this.log('\nðŸ’ª maglev/types.ts and maglev/section-mapping.ts have been generated')
  }

  private async codegen(rootPath: string) {
    let typeStr = ''
    const mapping: string[] = []
    const sectionDefinitions = await this.getSectionDefinitions(rootPath)

    for (const sectionDefinition of sectionDefinitions) {
      const sectionName = `${camelize(sectionDefinition.id, true)}Section`

      typeStr = ''.concat(
        ...typeStr,
        this.generateSectionType(sectionName, sectionDefinition),
        this.generateBlockTypes(sectionName, sectionDefinition),
      )

      mapping.push(this.generateSectionMapping(sectionName, sectionDefinition))

      this.log(`...${sectionName} âœ…`)
    }

    return Promise.all([
      this.writeTypesFile(rootPath, typeStr),
      this.writeMappingFile(rootPath, mapping.join(',')),
    ])
  }

  private writeMappingFile(rootPath: string, mappingStr: string): Promise<void> {
    const filepath = path.join(rootPath, 'maglev/section-mapping.ts')
    const content = `
// Generated by Maglev codegen
import * as CoreTypes from '~~/maglev-core/types'

const sectionDefinitionMapping: CoreTypes.SectionDefinitionMapping = {${mappingStr}
}

export { sectionDefinitionMapping }
    `.trim()

    return new Promise(resolve => {
      fs.writeFile(filepath, content, err => {
        if (err) throw err
        resolve()
      })
    })
  }

  private writeTypesFile(rootPath: string, typeStr: string): Promise<void> {
    const filepath = path.join(rootPath, 'maglev/types.ts')
    const content = `
// Generated by Maglev codegen
import * as CoreTypes from '~~/maglev-core/types'
${typeStr}
    `.trim()

    return new Promise(resolve => {
      fs.writeFile(filepath, content, err => {
        if (err) throw err
        resolve()
      })
    })
  }

  private generateSectionType(sectionName: string, sectionDefinition: SectionDefinition): string {
    return `
export type ${sectionName} = CoreTypes.Section & {
  id: string
  settings: {${sectionDefinition.settings.map(setting => `
    ${setting.id}: CoreTypes.${camelize(setting.type, true)}Setting`).join('')}
  }` + (sectionDefinition.blocks.length > 0 ? `
  blocks: (${sectionDefinition.blocks.map(block => `${sectionName}${camelize(block.type, true)}Block`)})[]` : '') + `
}
    `
  }

  private generateSectionMapping(sectionName: string, sectionDefinition: SectionDefinition): string {
    return `
  ${sectionDefinition.id}: {
    settings: {${sectionDefinition.settings.map(setting => `
      ${setting.id}: '${setting.type}'`).join(',')}
    },
    blocks: {${sectionDefinition.blocks.map(blockDefinition => `
      ${blockDefinition.type}: {
        settings: {${blockDefinition.settings.map(setting => `
          ${setting.id}: '${setting.type}'`).join(',')}
        }
      }`).join(',')}
    }
  }`
  }

  private generateBlockTypes(sectionName: string, sectionDefinition: SectionDefinition): string {
    return sectionDefinition.blocks.map(block => `
export type ${sectionName}${camelize(block.type, true)}Block = {
  id: string
  settings: {${block.settings.map(setting => `
    ${setting.id}: CoreTypes.${camelize(setting.type, true)}Setting`).join('')}
  }
}
    `).join('')
  }

  private async getSectionDefinitions(rootPath: string): Promise<SectionDefinition[]> {
    const ajv = new Ajv({allowUnionTypes: true})
    const files = await this.getSectionSchemaFiles(rootPath)

    const definitions: SectionDefinition[] = []

    for (const filepath of files) {
      const rawData = fs.readFileSync(filepath, {encoding: 'utf8', flag: 'r'})
      const data = JSON.parse(rawData)
      const valid = ajv.validate(SectionJsonSchema, data)
      if (!valid) {
        this.log(`ðŸš¨ ${path.basename(filepath)} is incorrect`)
        break
      }

      definitions.push(data as SectionDefinition)
    }

    return definitions
  }

  private getSectionSchemaFiles(rootPath: string): Promise<string[]> {
    return new Promise((resolve, reject) => {
      glob(`${rootPath}/**/maglev/**/*.schema.json`, (err: Error | null, files: string[]) => {
        if (err) reject()
        resolve(files.map(file => path.resolve(file)))
      })
    })
  }
}
